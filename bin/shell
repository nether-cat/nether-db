#!/usr/bin/env node

const XLSX = require('xlsx');
const util = require('util');

const seraph = require('../lib/server/database/seraph');
const allCountries = new (require('country-list'))();

let replacements = {
  // publication
  'weblink': 'url',
  'contact_mail': 'email',
  // lake
  'surface_level_elevation': 'surface_level',
  // core
  'core_label': 'label',
  // collection
  'proxytype': 'proxy',
  'name_of_dataset': 'label',
  'analysis_method': 'method',
};

let args = process.argv.slice(2);
let proxyName = args[0].toLowerCase();
let workbook = XLSX.readFile(args[1]);
let sheet, sheetTitle;
let sheetNotFound = function () {
  throw new Error('Sheet with records not found!');
};
try {
  let index = proxyName.charAt(0).toUpperCase() + proxyName.slice(1);
  sheet = workbook.Sheets[index];
  sheetTitle = sheet['B2'].v.trim().toLowerCase();
} catch (e) {
  sheetNotFound();
} finally {
  if (proxyName + ' template' !== sheetTitle) sheetNotFound();
}
let regex = /^[A-Z]{1,3}\d+:([A-Z]{1,3})(\d+)$/g;
let [, lastColumn, lastRow] = regex.exec(sheet['!ref']);
let namesRange = util.format('A8:%s%s', lastColumn, '8');
let valuesRange = util.format('A9:%s%s', lastColumn, lastRow);
let columnNames = XLSX.utils.sheet_to_json(sheet, {header: 1, range: namesRange})[0].map(
  el => el.trim().toLowerCase().replace(/\s/g, '_')
);
let metadata = XLSX.utils.sheet_to_json(workbook.Sheets['Metadata'], {header: 'A', range: 'B1:G81'});
let records = XLSX.utils.sheet_to_json(sheet, {header: columnNames, range: valuesRange});

metadata = metadata.reduce((accumulator, {B: property, G: value, __rowNum__: rowNumber}) => {
  if (!value || !property) {
    return accumulator;
  }
  let key = rowNumber < 26 ?
    'publication' : rowNumber < 47 ?
      'lake' : rowNumber < 65 ?
        'core' : 'collection';
  property = property.trim().toLowerCase()
    .replace(/[(:)]/g, '').replace(/[-/\s]+/g, '_');
  if (replacements.hasOwnProperty(property)) {
    property = replacements[property];
  }
  accumulator[key][property] = value;
  return accumulator;
}, {
  publication: {}, lake: {}, core: {}, collection: {}
});

const importData = async function () {
  let collection = Object.assign({}, metadata.collection, {
    sampledFrom: Object.assign({}, metadata.core, {
      drilledFrom: Object.assign({}, metadata.lake, {
        locatedIn: {},
      }),
    }),
    referencedBy: [],
    providesWith: {},
    includes: [],
  });
  let {
    /** @type {Model} */ Attribute,
    /** @type {Model} */ Collection,
    /** @type {Model} */ Core,
    /** @type {Model} */ Country,
    /** @type {Model} */ Lake,
    /** @type {Model} */ Proxy,
    /** @type {Model} */ Publication,
    /** @type {Model} */ Record,
    /** @type {Model} */ Synonym,
    /** @type {Model} */ User,
  } = seraph.models;
  return Promise.resolve()
    .then(() => Country.promise.where({code: metadata.lake['country']}))
    .then(countries => {
      collection.sampledFrom.drilledFrom.locatedIn = countries.length ? countries[0] : {
        code: metadata.lake['country'],
        name: allCountries.getName(metadata.lake['country'])
      };
      return Proxy.promise.where({name: proxyName});
    })
    .then(proxies => {
      collection.providesWith = proxies.length ? proxies[0] : {name: proxyName};
      let predicate = Object.entries(metadata.publication)
        .filter(([key]) => ['doi', 'source', 'url'].includes(key))
        .reduce((accumulator, [key, value]) => {
          return Object.defineProperty(accumulator, key, {value: value, enumerable: true})
        }, {});
      return Publication.promise.where(predicate, {any: true});
    })
    .then(publications => {
      collection.referencedBy = publications.length ? publications : [metadata.publication];
      return Collection.promise.save(collection);
    })
    .then(persistedCollection => {
      collection = persistedCollection;
      let attributeNames = columnNames.filter(() => true);
      collection.includes = attributeNames.map(key => ({name: key, characterizes: collection.providesWith}));
      let query = 'MATCH (node:Attribute)-[:CHARACTERIZES]->(:Proxy) WHERE node.name IN {names}';
      return Attribute.promise.query(query, {names: attributeNames});
    })
    .then(attributes => {
      collection.includes = collection.includes.map(attribute => {
        return attributes.find(obj => attribute.name === obj.name) || attribute
      });
      return Collection.promise.save(collection);
    })
    .catch(err => console.error(err.stack));
  /*
  let records = await Promise.all(
    records.map(row => {
      let data = Object.entries(row).reduce(
        (result, entry) => {
          if (['age', 'depth'].indexOf(entry[0]) === -1) {
            result.data[entry[0]] = entry[1];
          } else {
            result[entry[0]] = entry[1];
          }
          return result;
        }, {data: {}},
      );
      return db['record']
        .create(Object.assign({collection_id: collection.id}, data))
        .catch(err => console.log(err));
    })
  );
  */
};

importData().then(() => console.log('Finished!'));
