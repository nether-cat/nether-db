#!/usr/bin/env node

const { application } = require('../lib/server');
const isProd = process.env.NODE_ENV === 'production';
const port = normalizePort(process.env.PORT || '3000');

if (!isProd) {
  let bundle, clientManifest;
  const path = require('path');
  const MFS = require('memory-fs');
  const { reload } = require('../lib/server/renderer');
  const clientConfig = require('../webpack.client.config');
  const serverConfig = require('../webpack.server.config');
  const readFile = (fs, file) => {
    try {
      return fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8')
    } catch (e) {}
  };
  const update = () => {
    if (bundle && clientManifest) {
      reload(bundle, clientManifest);
    }
  };
  require('koa-webpack')({ config: clientConfig }).then((middleware) => {
    middleware.devMiddleware.context.compiler.name = 'ClientBundle';
    middleware.devMiddleware.context.compiler.hooks
      .done.tap('HotManifestPlugin', stats => {
        stats = stats.toJson();
        stats.errors.forEach(err => console.error(err));
        stats.warnings.forEach(err => console.warn(err));
        if (stats.errors.length) {
          return;
        }
        clientManifest = JSON.parse(readFile(
          middleware.devMiddleware.fileSystem,
          'vue-ssr-client-manifest.json',
        ));
        update();
      },
    );
    // add the middleware to the front of the array
    application.middleware.unshift(middleware);
  });
  // watch and update server renderer
  const webpack = require('webpack');
  const serverCompiler = webpack(serverConfig);
  const mfs = new MFS();
  serverCompiler.name = 'ServerBundle';
  serverCompiler.outputFileSystem = mfs;
  serverCompiler.watch({}, (err, stats) => {
    if (err) {
      throw err;
    }
    if (stats.hasErrors()) {
      return;
    } else if (stats.hasWarnings()) {
      stats.warnings.forEach(err => console.warn(err));
    }
    // read bundle generated by vue-ssr-webpack-plugin
    bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json'));
    update();
  });
}

const httpServer = application.listen(port, function () {
  console.log('HTTP server listening on http://localhost:' + port);
});

httpServer.on('close', function () {
  console.log('HTTP server has been closed gracefully!');
  application.shutdown();
});

process.on('SIGINT', function() {
  httpServer.close(function(err) {
    process.exit(err ? 1 : 0);
  });
});

function normalizePort (val) {
  let port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}
