#!/usr/bin/env node

let application, pendingShutdown, unlinkStaleAssets;
const isProd = process.env.NODE_ENV === 'production';
const port = normalizePort(process.env.PORT || '3000');

if (!isProd) {
  const assets = [];
  let bundle, clientManifest;
  const fs = require('fs');
  const path = require('path');
  const MFS = require('memory-fs');
  const clientConfig = require('../webpack.client.config');
  const serverConfig = require('../webpack.server.config');
  const readFile = (fs, file) => {
    try {
      return fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8')
    } catch (e) {}
  };
  const update = (middleware) => {
    if (bundle && clientManifest) {
      if (application) {
        require('../lib/server/renderer').reload(bundle, clientManifest);
      } else {
        ({ application } = require('../lib/server'));
        application.middleware.unshift(middleware);
        start();
      }
    }
  };
  require('koa-webpack')({
    config: clientConfig,
    devMiddleware: {
      headers: {
        'Cache-Control': 'public, max-age=31536000',
      },
      writeToDisk: true,
      stats: 'minimal',
    },
  }).then((middleware) => {
    middleware.devMiddleware.context.compiler.name = 'ClientBundle';
    middleware.devMiddleware.context.compiler.hooks
      .emit.tap('UnlinkStaleAssetsPlugin', compilation => {
        Promise.all(
          assets.splice(0).map(file => Promise.all([
            new Promise(resolve => middleware.devMiddleware.fileSystem.unlink(file, () => resolve())),
            new Promise(resolve => fs.unlink(file, () => resolve())),
          ])),
        ).then(() => {
          assets.push(...Object.keys(compilation.assets).map(name => path.normalize(
            middleware.devMiddleware.context.compiler.outputPath + '/' + name,
          )));
          unlinkStaleAssets = () => {
            return Promise.all(
              assets.splice(0).map(file => Promise.all([
                new Promise(resolve => middleware.devMiddleware.fileSystem.unlink(file, () => resolve())),
                new Promise(resolve => fs.unlink(file, () => resolve())),
              ])),
            );
          }
        });
      },
    );
    middleware.devMiddleware.context.compiler.hooks
      .done.tap('HotClientManifestPlugin', stats => {
        stats = stats.toJson();
        stats.errors.forEach(err => console.error(err));
        stats.warnings.forEach(err => console.warn(err));
        if (stats.errors.length) {
          return;
        }
        clientManifest = JSON.parse(readFile(
          middleware.devMiddleware.fileSystem,
          'vue-ssr-client-manifest.json',
        ));
        update(middleware);
      },
    );
    // watch and update server renderer
    const webpack = require('webpack');
    const serverCompiler = webpack(serverConfig);
    const mfs = new MFS();
    serverCompiler.name = 'ServerBundle';
    serverCompiler.outputFileSystem = mfs;
    serverCompiler.watch({}, (err, stats) => {
      if (err) {
        throw err;
      }
      if (stats.hasErrors()) {
        return;
      } else if (stats.hasWarnings()) {
        // noinspection JSUnresolvedVariable
        stats.warnings.forEach(err => console.warn(err));
      }
      // read bundle generated by vue-ssr-webpack-plugin
      let bundleName = 'vue-ssr-server-bundle.json';
      let bundleDiskPath = serverConfig.output.path + '/' + bundleName;
      let bundleString = readFile(mfs, bundleName);
      fs.writeFileSync(path.normalize(bundleDiskPath), bundleString);
      bundle = JSON.parse(bundleString);
      update(middleware);
    });
  });
} else {
  ({ application } = require('../lib/server'));
  start();
}

function start () {
  let server = application.listen(port, function () {
    console.log('HTTP server listening on http://localhost:' + port);
  });

  server.on('close', function () {
    console.log('HTTP server has been closed gracefully!');
    application.shutdown();
  });

  process.on('SIGINT', function() {
    if (pendingShutdown) {
      return;
    }
    pendingShutdown = true;
    if (typeof process.stdout.cursorTo === 'function') {
      process.stdout.cursorTo(0);
    }
    server.close(function(err) {
      Promise.all([
        (typeof unlinkStaleAssets === 'function') ? unlinkStaleAssets() : null,
      ]).then(() => process.exit(err ? 1 : 0));
    });
  });
}

function normalizePort (val) {
  let port = parseInt(val, 10);
  if (isNaN(port)) {
    // named pipe
    return val;
  }
  if (port >= 0) {
    // port number
    return port;
  }
  return false;
}
