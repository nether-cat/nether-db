scalar JSON

directive @auth(role: UserRole = USER) on OBJECT | FIELD_DEFINITION

enum AccessLevel {
  OWNER
  EDITOR
  VIEWER
  NONE
}

enum SessionState {
  AUTHORIZED
  AUTH_APPROVAL
  AUTH_EMAIL
  AUTH_ERROR
  AUTH_EXPIRED
  AUTH_FROZEN
  AUTH_PENDING
  AUTH_UNKNOWN
  UNAUTHORIZED
}

enum UserRole {
  ADMIN
  MANAGER
  REVIEWER
  USER
  NONE
}

input Password {
  isHash: Boolean!
  value: String!
}

input UserInput {
  titlePrefix: String
  fullName: String!
  shortName: String
  role: String
  department: String
  institution: String
  email: String!
  password: Password!
}

interface Entity {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String]
}

interface Permission @relation(name: "HAS_PERMISSION", from: "Entity", to: "Dataset") {
  uuid: ID!
  Dataset: Dataset!
  level: AccessLevel!
}

type Query {
  Session: Session!
  Credentials(currentPassword: Password, password: Password, token: String): JSON!
  Confirmation(token: String!): JSON!
  Test(_id: ID!): [JSON] @auth
  Country(_id: String, uuid: ID, code: String, name: String, first: Int, offset: Int, orderBy: String): [Country] @auth
  Dataset(_id: String, uuid: ID, first: Int, offset: Int, orderBy: String, filter: _EntityFilter): [Dataset] @auth
  Event: [Event] @auth @cypher(statement: """
    MATCH (e:Event)-[ref]-(r:Record)
    WITH e {
      .*,
      ageMean: avg(ref.age),
      ageMin: min(ref.age),
      ageMax: max(ref.age)
    }
    RETURN e
    ORDER BY e.ageMean
  """)
  GetByUUID(filter: _EntityFilter): [Entity] @auth(role: ADMIN)
  Lake(_id: String, uuid: ID, name: String, first: Int, offset: Int, orderBy: String, filter: _EntityFilter): [Lake] @auth
  User(_id: String, uuid: ID, email: String, first: Int, offset: Int, orderBy: String): [User] @auth(role: ADMIN)
}

type Mutation {
  Login(email: String!, password: Password!): Session!
  Logout: Session!
  Forgot(email: String!): JSON!
  SetPassword(currentPassword: Password, password: Password!, token: String): JSON!
  Signup(user: UserInput!, probeOnly: Boolean): JSON!
  Confirm(token: String!): JSON!
  Revoke(token: String!): JSON!
  UpdateLake(uuid: ID!, name: String): Lake! @auth(role: ADMIN)
  UpdateUser(uuid: ID!, emailVerified: Boolean, frozen: Boolean, userRole: UserRole, updated: _Neo4jDateTimeInput): User! @auth(role: ADMIN)
}

type Subscription {
  EntityUpdated(types: [String]): Entity! @auth
}

type Attribute implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  name: String!
  description: String
  categories(first: Int = 100, offset: Int = 0): [Category] @relation(name: "BELONGS_TO", direction: OUT)
}

type Category implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  name: String!
  description: String
  attributes(first: Int = 100, offset: Int = 0): [Attribute] @relation(name: "BELONGS_TO", direction: IN)
  datasets(first: Int = 100, offset: Int = 0): [Dataset] @relation(name: "BELONGS_TO", direction: IN)
}

type Changeset implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  payload: JSON!
}

type Core implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  label: String
  latitude: Float
  longitude: Float
  coringMethod: String
  drillDate: Int
  waterDepth: Float
  composite: Boolean
  ageDepthMethod: String
  comments: String
  datasets(first: Int = 100, offset: Int = 0): [Dataset] @relation(name: "SAMPLED_FROM", direction: IN)
  lake(first: Int = 1, offset: Int = 0): [Lake] @relation(name: "FROM_LAKE", direction: OUT)
}

type Continent implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  "Continent code as defined in the package [countries-list](https://www.npmjs.com/package/countries-list)."
  code: String!
  "English continent name as defined in the package [countries-list](https://www.npmjs.com/package/countries-list)."
  name: String!
  countries(first: Int = 100, offset: Int = 0): [Country] @relation(name: "LOCATED_IN", direction: IN)
}

type Country implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  "Country code as specified by the standard [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)."
  code: String!
  "English country name as defined in the package [countries-list](https://www.npmjs.com/package/countries-list)."
  name: String!
  continents(first: Int = 100, offset: Int = 0): [Continent] @relation(name: "LOCATED_IN", direction: OUT)
  lakes(first: Int = 100, offset: Int = 0): [Lake] @relation(name: "LOCATED_IN", direction: IN)
}

type Dataset implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  file: String!
  label: String
  samples: Int @cypher(statement: "MATCH (m:Record)-[r:RECORDED_IN]->(this) RETURN count(m)")
  ageMin: Float
  ageMax: Float
  depthMin: Float
  depthMax: Float
  ageSpan: Float
  ageResolution: Float
  depthSpan: Float
  depthResolution: Float
  analysisMethod: String
  comments: String
  url: String
  distributor: String
  attributes(first: Int = 100, offset: Int = 0): [Attribute] @cypher(statement: "MATCH (this)-[r:INCLUDES]->(m:Attribute) RETURN m ORDER by r.__colNum__ SKIP {offset} LIMIT {first}")
  categories(first: Int = 100, offset: Int = 0): [Category] @relation(name: "BELONGS_TO", direction: OUT)
  core(first: Int = 1, offset: Int = 0): [Core] @relation(name: "SAMPLED_FROM", direction: OUT)
  publication(first: Int = 1, offset: Int = 0): [Publication] @relation(name: "PUBLISHED_IN", direction: OUT)
  records(first: Int = 100, offset: Int = 0): [JSON] @cypher(statement: "MATCH (m:Record)-[r:RECORDED_IN]->(this) WITH m ORDER BY r.__rowNum__ ASC SKIP {offset} LIMIT {first} RETURN collect(m { .* })")
  accessLevel: AccessLevel! @cypher(statement: """
    OPTIONAL MATCH (u:User { email: $cypherParams.currentUser }),
      (u)-[p1:HAS_PERMISSION]->(this),
      (u)-[:MEMBER_OF*1..]->()-[p2:HAS_PERMISSION]->(this)
    WITH (collect(p1) + collect(p2)) as all
    UNWIND (all + [{ level: 'NONE' }]) AS p WITH DISTINCT p
    ORDER BY apoc.coll.indexOf($cypherParams.accessLevels, p.level)
    DESC LIMIT 1 RETURN p.level
  """)
  protected: Boolean
  permissions: [Permission]
}

type Event implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  name: String!
  ageMax: Float
  ageMean: Float
  ageMin: Float
  datasets(first: Int = 100, offset: Int = 0): [Dataset] @cypher(statement: "MATCH (e:Event { uuid: this.uuid })-[ref]-(r:Record)--(d:Dataset) WITH DISTINCT d SKIP {offset} LIMIT {first} RETURN d")
  lakes(first: Int = 100, offset: Int = 0): [Lake] @cypher(statement: "MATCH (e:Event { uuid: this.uuid })-[ref]-(r:Record)--(d:Dataset)--(:Core)--(l:Lake) WITH DISTINCT l SKIP {offset} LIMIT {first} RETURN l")
}

type Group implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  name: String!
  members: [User] @relation(name: "MEMBER_OF", direction: IN)
  children: [Group] @relation(name: "MEMBER_OF", direction: IN)
  parents: [Group] @relation(name: "MEMBER_OF", direction: OUT)
  permissions: [GroupPermission]
}

type GroupPermission implements Permission @relation(name: "HAS_PERMISSION", from: "Group", to: "Dataset") {
  uuid: ID!
  Group: Group!
  Dataset: Dataset!
  level: AccessLevel!
}

type Lake implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  name: String!
  latitude: Float!
  longitude: Float!
  maxDepth: Float
  surfaceLevel: Float
  surfaceArea: Float
  catchmentArea: Float
  waterBodyVolume: Float
  datasetsCount: Int @cypher(statement: "MATCH (this)--(:Core)--(d:Dataset) RETURN count(DISTINCT d)")
  cores(first: Int = 100, offset: Int = 0): [Core] @relation(name: "FROM_LAKE", direction: IN)
  countries(first: Int = 100, offset: Int = 0): [Country] @relation(name: "LOCATED_IN", direction: OUT)
}

type Publication implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  resolved: _Neo4jDateTime
  citation: String
  title: String
  authors: String
  year: Int
  doi: String
  source: String
  url: String
  email: String
  abstract: String
  datasets(first: Int = 100, offset: Int = 0): [Dataset] @relation(name: "PUBLISHED_IN", direction: IN)
}

type Session {
  _id: ID!
  user: String!
  userRole: UserRole!
  token: String
  expires: Float!
  state: SessionState!
}

type User implements Entity @additionalLabels(labels: ["Entity"]) {
  uuid: ID!
  created: _Neo4jDateTime!
  updated: _Neo4jDateTime!
  types: [String] @cypher(statement: "MATCH (this) RETURN labels(this)")
  titlePrefix: String
  fullName: String!
  shortName: String
  role: String
  department: String
  institution: String
  email: String!
  password: String!
  userRole: UserRole!
  deactivated: Boolean!
  emailVerified: Boolean!
  frozen: Boolean!
  reason: String
  groups: [Group] @relation(name: "MEMBER_OF", direction: OUT)
  permissions: [UserPermission]
}

type UserPermission implements Permission @relation(name: "HAS_PERMISSION", from: "User", to: "Dataset") {
  uuid: ID!
  User: User!
  Dataset: Dataset!
  level: AccessLevel!
}

# The input types below are being provided for Neo4j

input _EntityFilter {
  AND: [_EntityFilter]
  OR: [_EntityFilter]
  uuid: ID
  uuid_in: [ID!]
  uuid_starts_with: String
}

# The types below are being implemented by Neo4j

type _Neo4jDate {
  year: Int
  month: Int
  day: Int
  formatted: String
}

input _Neo4jDateInput {
  year: Int
  month: Int
  day: Int
  formatted: String
}

type _Neo4jDateTime {
  year: Int
  month: Int
  day: Int
  hour: Int
  minute: Int
  second: Int
  millisecond: Int
  microsecond: Int
  nanosecond: Int
  timezone: String
  formatted: String
}

input _Neo4jDateTimeInput {
  year: Int
  month: Int
  day: Int
  hour: Int
  minute: Int
  second: Int
  millisecond: Int
  microsecond: Int
  nanosecond: Int
  timezone: String
  formatted: String
}

type _Neo4jTime {
  hour: Int
  minute: Int
  second: Int
  millisecond: Int
  microsecond: Int
  nanosecond: Int
  timezone: String
  formatted: String
}

input _Neo4jTimeInput {
  hour: Int
  minute: Int
  second: Int
  nanosecond: Int
  millisecond: Int
  microsecond: Int
  timezone: String
  formatted: String
}

enum _RelationDirections {
  IN
  OUT
}

# The directives below are being implemented by Neo4j

directive @additionalLabels(labels: [String]) on OBJECT

directive @cypher(statement: String!) on FIELD_DEFINITION

directive @relation(
  name: String!,
  direction: _RelationDirections,
  from: String,
  to: String
) on FIELD_DEFINITION | OBJECT | INTERFACE

directive @neo4j_ignore on FIELD_DEFINITION
